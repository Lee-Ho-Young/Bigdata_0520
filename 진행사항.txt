<진행사항>
--------------------------------------------------
* 집 데스크탑 환경
	-- STS
	-- Oracle 12c 설치완료 [hr/hr 계정으로 로컬 접속 확인]
	
--------------------------------------------------

<정리사항2 - Oracle 로컬 on/off>
--------------------------------------------------
* 오랜만에 Oracle을 접속하려고 하니까 안됨
* 프로세스에 tnslsnr.exe가 떠 있음
* 시작 -> Oracle -> Administration Assistant for Windows -> 데이터베이스 우클릭 -> 서비스 시작
--------------------------------------------------

<정리사항1>
--------------------------------------------------
* jdbc.jar 파일을 external형식으로 사용할 경우, junit
  테스트는 정상적으로 수행되지만, 톰캣에 올릴때 에러가 난다.
* jdbc.jar 파일을 tomcat lib에 넣어주면 문제해결
  [프로젝트 내부에 lib폴더를 만들어서 jdbc.jar 파일을 포함해도 안됨]
--------------------------------------------------

<특이사항>
--------------------------------------------------
* TNS에러가 발생하면 오라클 인스턴스가 꺼져 있을 가능성이 있다.
* ojdbc 파일을 Maven으로 다운 받으려고 하는게 잘 안됨...
--------------------------------------------------
* ruby on rails 알아두면 좋을듯

<2020-04-08 Spring공부 - Maven>
* 메이븐은 COC(Convention over Configuration) 철학을 갖고 있어 설정된 포맷을 지켜줘야 한다.
* 메이븐 프로젝트는 프로젝트 루트에 pom.xml 파일이 있다.

-- Project 생성 : Spring Legacy Project [simple spring web maven] -> springExample1
	-- 쓸모없는 Lib들이 들어가 있는 경우가 많다.
	-- 바닥부터 필요한 것들을 추가해 가는 방법을 알아야 한다.
	
-- 프로젝트를 밑바닥부터 만들어 보자
	-- Dynamic Web Project [springExample01]
		-- STS에서 NEW항목에 Dynamic Web Project가 안 보일 경우 추가로 설치해야 함
		-- Dynamic web module version : 3.1
		-- Apache tomcat 8.0
		-- Spring 4.x 버전 지원
		
		-- 프로젝트 생성 단계에서 소스 디렉토리의 경로를 Maven Convention에 맞게 수정
			-- src.main.java
			-- src.main.resources
			-- src.test.java
			-- src.test.resources
		-- 프로젝트 생성 단계에서 Content directory를 Maven에 맞게 수정
			-- WebContent -> src/main/webapp
			-- Generate web.xml deployment descriptor 체크하기
		
		-- Maven Project로 전환
			-- 프로젝트 우클릭 Configure -> Convert to Maven Project
			-- 그룹ID 설정
			-- Artiface ID 설정
			-- 버전 설정
			
		-- 메이븐 프로젝트를 Spring 프로젝트로 변환
			-- Spring관련 lib를 Maven dependency에 추가
				-- Spring Context
					<dependency>
						<groupId>org.springframework</groupId>
						<artifactId>spring-context</artifactId>
						<version>4.3.26.RELEASE</version>
					</dependency>
		
			
			
			
<2020-04-08 Spring공부 - IoC>
* 스프링은 스프링 컨테이너에 빈(자바객체)을 로딩하여 관리한다.
* 빈을 자동으로 관리해 주는 기능(IoC)은 스프링의 핵심 기능 중 하나이다.

* IoC는 Inversion of Control의 약어로 객체의 제어를 프로그래머가 아닌 시스템이 한다는 뜻
* DI : Dependency Injection
* DL : Dependency Lookup

* IoC 컨테이너 : 스프링 프레임워크도 객체에 대한 생성 및 생명주기를 관리할 수 있는 기능을 제공
	-- IoC 컨테이너는 객체의 생성을 책임지고, 의존성을 관리한다.
	-- POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다.
	-- 개발자가 직접 POJO를 생성할 수 있지만 컨테이너에게 맡긴다.
* IoC에는 2가지의 기능이 있어야 한다. -> DL / DI
	-- 필요한 객체를 찾을 수 있어야 하고
	-- 객체간 의존관계를 주입해 줄 수 있어야 함
	ex) A객체를 찾고, A가 참조하는 것들을 설정해줌
	-- DI : Setter Injection, Constructor Injection, Method Injection
* DL : 저장소에 저장되어 있는 Bean에 접근하기 위해 컨테이너가 제공하는
      API를 사용하여 Bean을 Lookup 하는 것  
* DI : 각 클래스간의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결
* Managed Bean : 스트링 컨테이너에 의해서 관리되는 객체
	-- 스프링 Bean이라고도 함
	-- 스프링 설정파일에 등록되어 사용 [자동 등록 기능도 있음]
* Spring Container : 
	-- 관리되는 빈이 모여 있는 곳
	-- IoC 컨테이너로써 Application Context 클래스로 구현됨

* TestDAO 작성하여 그냥 호출해보고, 빈 컨테이너에 등록 후 IoC를 사용하여 호출해 보자
	-- src/main/resources 폴더에 spring 설정파일 생성 필요
	-- new - other - spring bean configuration file
	-- 파일명 : spring-context.xml
	-- spring-context.xml 파일에 bean을 id값과 class값으로 정의
		-- id값은 클래스명과 동일하되 첫글자를 소문자로 기재
		-- class값은 fully qualified name
	------------------------------------------------------------------
	public static void main(String[] args) {
		/* 명시적인 생성 삭제 */
		//TestDAO dao = new TestDAO();
		//int result = dao.addTwoNumber(3, 5);
		//System.out.println(result);
		
		/* 이미 생성된 Bean을 가져왔다가 반환 (인스턴스 생성/삭제의 무거움을 던다.) */
		AbstractApplicationContext ctx = 
			new ClassPathXmlApplicationContext("/spring-context.xml");
		
		TestDAO dao = ctx.getBean("testDAO", TestDAO.class);
		int result = dao.addTwoNumber(3, 10);
		System.out.println(result);		
	}
	------------------------------------------------------------------


<2020-04-09 Spring공부 5강 - DI>
* DI : 각 클래스간의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것	
	- 개발자들은 단지 빈 설정파일에서 의존관계가 필요하다는 정보를 추가
	- 객체 레퍼런스를 컨테이너로부터 주입 받아, 실행 시에 동적으로 의존관계가 생성됨
	- 코드가 단순해진다. 컴포넌트간의 결합도가 제거된다.
	
* DI유형 : 
	- Setter Injection
	- Constructor Injection
	- Method Injection

* Spring DI 컨터에너가 관리하는 객체를 빈이라고 하고, 이 빈들을 관리하는 컨테이너를
  빈 팩토리라고 부른다.
	- Bean Factory : 
		- Bean을 등록, 생성, 조회, 반환 관리
		- 보통 Bean Factory를 바로 사용하지 않고, 이를 확장한 Application Context를 사용
		- getBean() 메서드가 정의되어 있음
	- Application Context : 
		- Bean을 등록, 생성, 조회, 반환 관리하는 기능은 Bean Factory와 동일
		- Spring의 각종 부가 서비스를 추가로 제공
		- Spring이 제공하는 Application Context 구현 클래스가 여러가지 종류가 있음
		
* 실습 : 
	- Service 클래스를 만들어 DAO를 참조
	- Dependency Injection을 통한 참조
		- Setter Injection
			- Service에서 코드로 객체를 생성하지 않고
			  적합한 setter함수를 생성
			- spring-context.xml 파일의 bean설정
			  property 속성으로 넣고자하는 파라미터 정의
			  <property name="testDAO" ref="testDAO"></property>
		- Constructor Injection
			- Service에서 사용할 객체를 받는 생성자를 정의
			- spring-context.xml 파일의 bean 설정
			  constructor 속성으로 넣고자하는 파라미터 정의
			  <constructor-arg ref="testDAO" />
		- 두 개의 DAO를 사용하는 예제
			- 하나의 DAO는 Setter Injection
			- 하나의 DAO는 Constructor Injection을 사용
			<bean id="testService" class="kr.com.acomp.service.TestService" >
				<constructor-arg ref="testDAO" />
				<property name="anotherDAO" ref="anotherDAO"></property>
			</bean>
		
			
<2020-04-09 Spring공부 6강 - Layered Architecture & @Component>	
* 계층화 아키텍쳐
	- 효율적인 개발과 유지보수를 위해 계층화 하여 개발
	- 대부분의 중/대규모 어플리케이션에서 적용
	- 각 레이어는 독립된 R&R을 가짐	
* 프레젠테이션 영역
	- 사용자와 상호작용을 담당
* 비지니스 영역
	- 기능/트랜잭션을 수행
* 데이터 영역
	- 데이터의 저장과 조회를 담당
	- 주로 데이터베이스와 연동하여 작업

* MVC 패턴
	- Layered Architecture를 사용한 대표적 패턴
	- 어플리케이션을 Model, View, Controller로 구분
	- UI를 가지는 대부분의 어플리케이션은 MVC혹은 변형된 MVC 패턴을 사용
	  [Angular, Android, iOS, SpringMVC..]

* 어노테이션을 사용한 컴포넌트 자동등록
	- @Component
		- @Controller
		- @Service
		- @Repository
	- <context:component-scan base-package="패키지명" />
		- 패키지명 이후 하위 패키지를 검색해 @Component 어노테이션을
		  포함하는 모든 클래스를 빈으로 자동 등록
		- context:component-scan : 
			- Bean이 될 수 있는 모든 Component들을 자동으로 찾아 Bean container에 등록
			- 단, 의존성 관계 등록은 따로 하지 않음
		- @Autowired : 
			- Component 간의 의존관계는 Autowired라는 Annotation으로 적용
			- Component-scan과 수동(Setter, Constructor) DI는 혼용해서 사용 가능

* 실습 : 
	- 게시판의 글쓰기 기능 구현
		- BbsService.registArticle(Article )
		- ArticleDAO.insertArticle(Article )
	- Service, DAO, VO Layering
	
	- @Service, @Repository 어노테이션 등록 및 <context:component-can .../> 사용
		- spring-context.xml 파일에서 context 네임스페이스를 사용하기 위해서는
		  Namespaces 탭에서 context 항목을 체크해 주어야 한다.
	- @Autowired 사용으로 DI구현


<2020-04-09 Spring공부 7강 - Spring MVC 소개>	
* MVC 패턴의 개념
	- 모델/뷰/컨트롤러는 소프트웨어 공학에서 사용되는 아키텍처 패턴으로
	  Business logic, Presentation logic 분리가 목적이다.
		- Controller : 요청처리 및 흐름 제어 담당
		- Model : 비지니스 로직 및 데이터 처리 담당 [Service + DAO]
		- View : 모델이 처리한 결과 데이터의 화면 생성 담당

* Front Controller 패턴 아키텍처
	- 클라이언트 -> Front Controller -> 다수의 Controller
	- Front Controller는 클라이언트가 보낸 요청을 받아서 공통적인 작업을 먼저 수행
	- Front Controller는 적절한 세부 Controller에게 작업을 위임
	- 각각의 애플리케이션 Controller는 클라이언트에게 보낼 뷰를 선택해서 최종 결과를 생성
	- Front controller 패턴은 인증이나 권한 체크처럼 모든 요청에 대하여
	  공통적으로 처리해야 하는 로직이 있을 경우 전체적으로 클라이언트의 요청을 
	  중앙 집중적으로 관리하고자 할 경우에 사용
	- Spring에서는 Front Controller를 미리 만들어 내장해 두었음

* Spring MVC의 특징
	- Spring은 DI나 AOP같은 기능뿐만 아니라, 서블릿 기반의 웹 개발을 위한 MVC프레임워크를 제공
	- Spring MVC는 모델2 아키텍처와 Front Controller 패턴을 프레임워크 차원에서  제공
	- Spring MVC 프레임워크는 Spring을 기반으로 하고 있기 때문에, Spring이 제공하는 트랜잭션 
	  처리나 DI 및 AOP등을 손쉽게 사용
	  
* Spring MVC / Front Cotroller 패턴
	- 대부분의 MVC 프레임워크들은 Front Controller 패턴을 적용해서 구현
	- Spring MVC도 Front Controller 역할을 하는 DispatcherServlet이라는 클래스를
	  계층의 맨 앞단에 놓고, 서버로 들어오는 모든 요청을 받아서 처리하도록 구성
	- 예외가 발생했을 때 일관된 방식으로 처리하는 것도 Front Controller의 역할

* Spring MVC의 주요 구성 요소
	- DispatcherServlet : 클라이언트의 요청을 받아 Controller에게 클라이언트의 요청을 전달하고, 리턴한 결과값을 View에게 전달하여 알맞은 응답을 생성
	- HandlerMapping : URL과 요청 정보를 기준으로 어떤 핸들러 객체를 사용할지 결정하는 객체이며, DispatcherServlet은 하나 이상의 핸들러 매핑을 가질 수 있다.
	- Controller : 클라이언트의 요청을 처리한 뒤, Model을 호출하고 그 결과를 DispatcherServlet에게 전달
	- ModelAndView : Controller가 처리한 데이터 및 화면에 대한 정보를 보유한 객체
	- View : Controller의 처리 결과 화면에 대한 정보를 보유한 객체
	- ViewResolver : Controller가 리턴한 뷰 이름을 기반으로 Controller 처리 결과를 생성할 뷰를 결정
	
	1) DispatcherServlet으로 요청이 들어옴
	2) DispatcherServlet은 HandlerMapping을 통해 적합한 Controller 정보를 찾음
	3) DispatcherServlet은 적합한 Controller에게 요청을 전달
	4) Controller는 결과적으로 반환된 값을 ModelAndView 객체로 DispatcherServlet에 반환
	5) DispatcherServlet은 ViewResolver를 통해 ModelAndView에 포함된 화면 정보를 확인
	6) DispatcherServlet은 적합한 View를 찾아 최종적으로 요청에 대한 응답을 보냄

* web.xml
	- DispatcherServlet : web.xml 파일에 등록해야 함
	- encodingFilter : 깨지지 않는 한글표현을 위해

* 실습
	- spring-mvc 라이브러리 설정
		- maven : pom.xml에 dependency 추가
		==============================================
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>4.3.26.RELEASE</version>
		</dependency>
		==============================================

	- DispatcherServlet 설정 [web.xml]
	==============================================================
		<servlet>
			<servlet-name>dispatcherServlet</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServelt</servlet-class>
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>/WEB-INF/spring/servlet-context.xml</param-value>
			</init-param>
		</servlet>
		<servlet-mapping>
			<servlet-name>dispatcherServlet</servlet-name>
			<url-pattern>/</url-pattern>
		</servlet-mapping>
	==============================================================	
	
	- 스프링 빈 설정파일 [servlet-context.xml]
		- servlet-context.xml 파일을 생성부터 해야한다.
			- WEB-INF/spring/servelt-context.xml 생성필요
			- servlet-context.xml 파일의 경우 new -> other -> Spring
			  에서 Spring Bean Configuration File을 선택해서 생성해야 한다.
			- <context:component-scan...>
			- <mvc:annotation-driven />
			- viewResolver 설정
			============================================================
				<context:component-scan base-package="kr.com.acomp" />
				<mvc:annotation-driven></mvc:annotation-driven>
				<!--  ViewResolver -->
				<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
					<property name="prefix" value="/WEB-INF/views/" />
					<property name="suffix" value=".jsp" />
				</bean>
			============================================================

* 정리 : 
	- 스프링 MVC는 스프링 프로젝트 중 일부이며 웹 어플리케이션 작성을
	  MVC패턴으로 구현한 프레임워크이다.
	- Front Controller인 DispatcherServlet이라 불리는 스프링 내장
	  서블릿은 스프링 MVC의 핵심이며 web.xml에서 설정된다.


<2020-04-13 Spring공부 8강 - @Controller>	
* DispatcherServelt : 
	- 웹 어플리케이션 최전방에서 사용자 요청을 접수
	- URL을 기준으로  요청을 처리할 Controller를 찾음
	- 해당 Controller를 호출 및 실행
	
* Controller
	- 사용자 요청(URL기반)에 해당하는 Controller의 특정 메소드가 호출됨
	- Controller는 요청의 파라미터가 있으면 처리
	- 비지니스 처리를 위해서 서비스 컴포넌트를 주입 받아서 실행
	- 실행된 결과를 전달받아 화면에 대한 정보와 함께 DispatcherServlet에게 반환
	- 사용되는 Annotation : @Controller, @RequestMapping, @Autowired

* @RequestMapping
	- Class Level Mapping vs Method Level Mapping
	- 클래스 레벨 url + 메소드 레벨 url이 결합된 것이 최종 요청 URL값이 된다.
	- 요청 방식 : GET, POST, PUT, DELETE
	  [URL이 동일해도 요청 방식이 다르면, 다른 메소드로 처리 가능]
	- Spring 4.3 이후
		- @GetMapping, @PostMapping, @PutMapping, @DeleteMapping
			- AS-IS : @RequestMapping(value="/bbs/write", method-RequestMethod.POST)
			- TO-BE : @PostMapping(value="/bbs/write")
		
* @RequestMapping::@PathVariable
	- 요청 URL을 파라미터로 사용 (경로변수)
	- ex) http://cafe/daum.net/sq99/2hq/68443
	- 파라미터로 처리 : @PathVariable("articleId") String articleId
	- ex) URL 자체를 변수로 받는 방법, 다음 카페에서 카페명이 URL에 직접 포함되는 것이 대표적이 예시
	    ========================================================================
		@RequestMapping("/{articleId}")
		public String viewDetail(@PathVariable String articleId) {
			Article article = service.viewArticle(articleId);
			
			return new ModelAndView("bbs/view_detail").addObject("article", article);
		}
	    ========================================================================
		
* ModelAndView를 사용한 모델/뷰 처리
	- 응답으로 View(JSP)와 Model을 함께 처리할 때 사용
	- 서비스로부터 받아온 데이터를 뷰로 전달해주는 역할
	
* Redirect & Forward
	- 컨트롤러에서 클라이언트의 요청을 처리한 후에 다른 페이지로 리다이렉트 하고 싶을때 : 
		- return "redirect:/bbs/list"; [return을 하면서 다른 URL로 보내버림]
		- return "forward:/bbs/list";
		===========================================================
		// 상대경로를 사용할 경우, 현재 요청받은 경로의 아래로 붙는다.
		@RequestMapping("/header/createauth")
		public String createAuth() {
			return "redirect:main";
		}
		===========================================================		
		===========================================================
		// Full URL을 적으면, 해당 URL로 리다이렉트 된다.
		@RequestMapping("/header/createauth")
		public String createAuth() {
			return "redirect:http://localhost:8080/TotalTest";
		}
		===========================================================		

* 실습
	* URL을 지정하고, 화면에 보여주기
	==============================================
	@Controller
	@RequestMapping("/bbs")
	public class BbsController {
	
		@Autowired
		private BbsService service;
		
		@RequestMapping("/write")
		public String write() {
			service.registArticle(new Article());
			
			return "write";
		}
	}
	==============================================
	
	* URL을 지정하고, 파라미터 넘겨보기
	==============================================
	@Controller
	@RequestMapping("/bbs")
	public class BbsController {
	
		@Autowired
		private BbsService service;
		
		@RequestMapping("/write")
		public String write(@RequestParam("author") String author) {
			service.registArticle(new Article());
			System.out.println(author);
			return "write";
		}
	}
	==============================================


			
<2020-04-19 9강 HTTP 파라미터 처리>				
* 파라미터 전송받기 : @RequestParam
	- @RequestParam 어노테이션을 이용한 요청 파라미터 구하기
	- get / post로 요청을 넘겨 받음
	- required=false는 요청 값이 없을 때 에러를 보내지 않고 null을 리턴
	  [@RequestParam(value="id", required=false, defaultValue="") String id]
			
	- Command 객체를 이용해 폼 전송 처리하기
	- form 내부의 객체들이 갖고 있는 name 속성들이 서버에 파라미터로 전달
	ex) form 내부에 email , name, password, confirmPassword 4개의 name을 갖는 객체가 있을때
		1) 기존의 Get방식으로 받는 것처럼 하나 하나 받을 수도 있음
		===================================================================
		   @RequestMapping(value="/url~", method=RequestMethod.POST)
		   public ModelAndView test (
				@RequestParam("email") String email,
				@RequestParam("name") String name,
				@RequestParam("password") String password,
				@RequestParam("confirmPassword") String confirmPassword,
 		   ) {}
		===================================================================

		2) Post 방식의 요청을 한번에 받는 방법 [유지보수가 편함]
			- Command 객체를 이용해 폼 전송 처리하기
			- 파라미터 이름과 동일한 속성을 가진 클래스를 작성 [vo]
			- 자동으로 바인딩이 일어난다.
			- 타입 자동 변환 기능
				- 모든 파라미터는 String 형식으로 넘어온다.
				- 숫자는 int(long), double 타입으로 vo객체에서 지정되 두면 자동 형변환
				- true, false는 boolean 타입으로 vo객체에서 지정되 두면 자동 형변환
				- 체크박스의 경우 여러개를 선택할 경우, List<String> 형식으로 자동 형변환
		===================================================================			
			@RequestMapping(value="/url~", method=RequestMethod.POST)
			public ModelAndView test (Member member){}
			
			public class Member{
				private String email;
				private String name;
				private String password;
				private String confirmPassword;
			}
		===================================================================				
			
* 실습
	- GET방식 / POST방식 처리
		- Controller에서 Method를 적어주지 않으면 default로 GET방식임
		- Spring 4.3 이후에는 GET/POST 구분이 쉬워졌다.

			@RequestMapping(value="/write", method=RequestMethod.POST)
			@RequestMapping(value="/write", method=RequestMethod.GET)
			@RequestMapping(value="/write", method={RequestMethod.GET, RequestMethod.POST})
			
			@PostMapping("/wirte")
			@GetMapping("/write")
			
	- path variable 처리
		- 글번호가 URL에 포함되어 변수형태로 들어오는 방식
		=======================================================================
		@GetMapping("/{articleId}")
		public String viewDetail(@PathVariable("articleId") String articleId) {
			System.out.println("글번호 : " + articleId);
			return "write";
		}
		=======================================================================		
		
	- command 객체(vo)를 사용한 파라미터 처리
		=======================================================================
		* Postman에서 POST 방식으로 테스트를 진행할 때!
			- Body 영역의 x-www-form-urlencoded 옵션을 선택 후 파라미터를 넣을 수 있다.
		
		//Command 객체를 사용한 파라미터 자동 Binding
		@PostMapping(value="/write2")
		public String doWriteWithVO(Article article) {
			service.registArticle(article);
			System.out.println("post request...");
			return "write";
		}
		=======================================================================
			
	- ModelAndView로 JSP 페이지에 데이터 전달
		- jsp에 값을 전달하고 싶을때!
		- Controller return type값을 ModelAndView로 해야 한다.
		  [String 값으로 jsp 이름만 return하는 것과 다르게!]
		=======================================================================			
		//Command 객체를 사용한 파라미터 자동 Binding
		@PostMapping(value="/write3")
		public ModelAndView doWriteWithVO2(Article article) {
			service.registArticle(article);
			System.out.println("post request...");
			return new ModelAndView("write").addObject("article", article);
		}			
				
		<!-- 화면에서 사용할때! -->		
		<ul>
			<li>${article.articleId}</li>
			<li>${article.author}</li>
			<li>${article.title}</li>			
			<li>${article.content}</li>
		</ul>		
		=======================================================================
			
* 정리 
	- HTTP 요청 파라미터를 처리하기 위해 스프링은 @RequestParam 어노테이션을 제공
	- HTTP 파라미터는 자바 객체와 대응되며, 일반적으로 이름이 같으며 자동으로 매핑된다.
			
			
<2020-04-19 10강 Restful API>			
* Open API(Application Programming Interface)?
	- API가 응용 프로그램을 개발할 때 사용하는 인터페이스라는 의미이므로, Open API는
	  프로그래밍에서 사용할 수 있는 개방되어 있는 상태의 인터페이스를 말한다.
	- Open API와 함께 자주 거론되는 기술이 REST이며, 대부분 Open API는 REST 방식으로 지원되고 있다.
			
* REST(Representational State Transfer) API
	- HTTP URI + HTTP Method
	- HTTP URI를 통해 제어할 자원(Resource)를 명시하고, HTTP Method(GET, POST, PUT, DELETE)
	  를 통해 해당 자원(Resource)를 제어하는 명령을 내리는 방식의 아키텍처
	- HTTP 프로토콜에 정의된 4개의 메서드들이 자원에 대한 CRUD 오퍼레이션을 정의
		- POST [INSERT], GET [SELECT], PUT [UPDATE/CREATE], DELETE [DELETE]
			
* 기존의 웹 접근 방식과 RESTful API 방식과의 차이점
	- 기존 게시판은 get/post만으로 자원에 대한 CRUD를 처리하며, URI는 액션을 나타낸다.
	- RESTful 게시판은 4가지 메서드를 모두 사용하여 CRUD를 처리하며, URI는 제어하려는 자원을 나타낸다.
	  [URI에 액션을 배제해야 한다.]
	- RESTful 웹서비스와 JSON/XML
		- 요청과 응답은 주로 JSON/XML 등의 형식을 사용한다. 
			
* JSON(JavaScript Object Notation)
	- JSON은 경량 DATA 교환 형식
	- Javascript에서 객체를 만들 때 사용하는 표현식을 의미
	- key : value 형식의 pair 형식
	- JSON 라이브러리 - Jackson
		- Jackson은 JSON 형태를 Java 객체로, Java객체를 JSON 형태로 
		  변환해주는 Java용 JSON 라이브러리
	
* Spring MVC기반 RESTful 웹서비스 구현 절차
	- RESTful 웹서비스를 처리할 RestfulController 클래스 작성 및 Spring Bean 등록
	- 요청을 처리할 메서드에 @RequestMapping, @RequestBody, @ ResponseBody 어노테이션 선언
	- REST Client Tool (Postman)을 사용하여 각각의 메서드 테스트
	- Ajax 통신을 하여 RESTful 웹서비스를 호출하는 HTML 페이지 작성
	- 사용자 관리 RESTful 웹서비스 URI/Method 설계 사례
	----------------------------------
	/ ACTION / 	URI 		/ Method
	----------------------------------
	사용자 목록	/users		  GET	
	사용자 보기	/users/{id}	  GET
	사용자 등록	/users		  POST
	사용자 수정	/users/{id}	  PUT
	사용자 삭제	/users/{id}	  DELETE
	----------------------------------
			
* RESTful Controller를 위한 핵심 어노테이션
	- Spring MVC에서는 클라이언트에서 전송한 XML이나 JSON 데이터를
	  Controller에서 JAVA객체로 변환해서 받을 수 있는 기능을 제공
	- JAVA 객체를 XML이나 JSON으로 변환해서 전송할 수 있는 기능을 제공
	- @RequestBody : HTTP Request Body를 JAVA객체로 전달받을 수 있다.
	- @ResponseBody : Java 객체를 HTTP Response Body로 전송할 수 있다.
			
* 실습
	- RESTful service 개발 :: @ResponseBody
		- Controller는 일반적으로 ModelAndView 객체 혹은 String만 반환
		- Java 객체를 반환하고자 하면, @ResponseBody 어노테이션 필요
		- Java 객체를 JSON으로 변환해줄 Jackson 라이브러리 필요
		=========================================================================
		//RESTful 글 읽기 [JSON형식으로 반환이 되는가?]
		@GetMapping("/{articleId}")
		@ResponseBody
		public Article viewDeatil(@PathVariable("articleId") String articleId) {
			Article article = service.viewArticleDetail(articleId);
			return article;
		}
		=========================================================================

		=========================================================================	
		<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.9.10.4</version>
		</dependency>
		=========================================================================

		=========================================================================
		* 요청 : http://localhost:8080/vlsSpring/bbs/10 [GET]
		* 응답 : 
			{
				"articleId": 10,
				"author": "lee",
				"title": "test",
				"content": "테스트입니다."
			}
		=========================================================================

		* RESTful 글 쓰기 : 
			- JSON형식으로 던진 값을 @RequestBody 어노테이션을 통해 JAVA객체로 받음
			- 받은 JAVA객체를 반환하기 위해 @ResponseBody 어노테이션 사용
		=========================================================================
		//RESTful 글 쓰기 [JSON형식의 데이터가 잘 전달되는가?]
		@PostMapping("/write4")
		@ResponseBody
		public Article writeArticle(@RequestBody Article article) {
			Article a = article;
			return a;
		}
		=========================================================================

	- Postman을 통한 테스트
		- JSON 형식으로 요청을 만들고 싶으면 BODY에서 raw 선택 후 데이터 타입을 JSON 선택 [Type : JSON]
		- 공간에 JSON형식으로 보내고자 하는 데이터 작성
		
* 정리 : 
	- API 서비스가 RESTful 하다는 의미
		- API의 Endpoint가 오직 하나이다.
		- 요청과 응답에 대한 메타데이터는 HTTP 프로토콜 방식을 사용한다.
		
		
<2020-04-20 11강 static file 처리와 FileUpload>
* Static Web Resource 처리하기
	- 서버상에서 처리가 이루어지지 않고 클라이언트로 파일 자체가 전송이 되는 파일을 static 파일이라고 한다.
	- 서버의 처리가 필요 없는 satic web resources는 요청 시 서버를 거치지 않고 곧바로 응답 필요
	- 특정 URL로 요청이 오면 static resource로 인식하고 바로 응답 수행
	- 이미지, javascript, css 등을 의미한다.
	
* Spring에서는 static resource를 분리하여 빠른 처리를 지원한다.
  [FrontController에서 정적인 자원을 바로 반환해 버린다.]
	- <mvc:resources mapping="/resources/**" location="/WEB-INF/resources/" />
	- mapping : HTTP 요청 URL
	- location : 실제 응답 할 파일이 있는 위치
	- 예시 : 요청 -> http://localhost:8080/hello/resources/scripts/jQuery.js
		    응답 -> /WEB-INF/resources/scripts/jQuery.js
			
* 파일 업로드 시 HTML 파일
	- <form method="post" enctype="multipart/form-data"> </form>
	
* 멀티파트 지원 기능을 사용하기 위해서 MultipartResolver를 스프링 빈으로 등록
	- MultipartResolver는 encType이 multipart/form-data 형식으로 데이터가
	  전송되었을 경우 해당 데이터를 Spring MVC에서 사용할 수 있도록 변환해준다.
	- 프라퍼티 : 
		- maxUploadSize : long 타입, 최대 업로드 가능한 바이트 크기를 의미 (-1 : 제한이 없음, default : -1)
		- maxInMemorySize : Int 타입, 디스크에 임시 파일을 생성하기 전에 메모리에 보관할 수 있는 최대 바이트 크기
							[default : 10240 바이트]
		- defaultEncoding : String 타입, 요청을 파싱할 때 사용할 캐릭터 인코딩. 지정하지 않을 경우, 
		                    HttpServletRequest.setCharacterEncoding() 메서드로 지정한 캐릭터 셋이 사용된다.
							[default : ISO-8859-1]

* 파일 업로드 사용 : Dependency 추가 필요
	- CommonsMultipartResolver : Apache Commons FileUpload 사용
	- form 작성 : <input type="file">
	
* Controller File Upload Logic 추가
	- MultipartFile : 메모리에 파일을 갖고 있음
	- transfer : 파일 시스템에 메모리 상의 데이터를 저장
	====================================================================
	@RequestMapping("/upload")
	public String doUpload(@RequestParam("name") String name,
						   @RequestParam("file") MultipartFile file, Model model) {
		if(!file.isEmpty()) {
			File tmpFile = new File("C:\\", file.getOriginalFilename());
			File.transferTo(tmpFile);
		}
		
		Model.addAttribute("fileNameK", name);
		return "upload_ok"
	}
	====================================================================
	
* MultipartFile 주요 메소드 
	- String getName()
	- String getOriginalFilename(); [업모르한 파일의 이름을 구한다.]
	- Boolean isEmpty()
	- Long getSize()
	- Byte[] getBytes()
	- InputStream getInputStream()
	- void transferTo(destination)
	
* Command 객체로 받아오기
	- VO객체의 속성에 private MultipartFile file; 
	  이런식으로 하나 지정해 두면 다른 form 데이터들과 마찬가지로 자동 바인딩
    - 일반 HttpServletRequest와 동일하게 MultipartFile도 Commnad 객체로 받을 수 있다.
	- 멤버 변수의 타입이 MultipartFile로 선언되어야 한다.
	
* 파일 저장 시 보안사항
	- 업로드 된 파일 이름을 그대로 사용해서 저장을 하게 되면, 추후 파일 다운로드 및 보안사항에 문제 발생
	- 파일 이름을 숨기고 실제 파일명을 난수화 시켜서 저장하는 것을 추천
	- 파일의 Readable 이름과 난수화된 이름을 모두 Database에 저장하여 매핑하는 방식
	-> String fileRandomName = UUID.randomUUID().toString();
		- 파일의 이름을 난수화 시키는 방법
		- 현재 시간을 기준으로 하기 때문에 중복이 될 수 없는 난수 생성
		
* 실습
	- static resource 처리
		1) index.jsp 파일을 하나 만들고, 거기서는 css파일과 이미지 파일을 사용한다.
		============================================================
		<%@ page language="java" contentType="text/html; charset=EUC-KR"
			pageEncoding="EUC-KR"%>
		<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
		<html>
		<head>
		<meta http-equiv="Content-Type" content="text/html; charset=EUC-KR">
		<title>index</title>
		<link rel="stylesheet" href="/vlsSpring/resources/styles/style.css">
		</head>
		<body>
			<h1>Spring Index page</h1>
			<img alt="스프링 이미지" src="/vlsSpring/resources/images/spring.png">
		
		</body>
		</html>
		============================================================
		
		2) 정적인 파일들이 모두 있을 경우, 컨트롤러에서 정상적으로 화면을 호출해도 
		   정적인 컨텐츠는 404 에러가 뜬다.		   
		   
		3) DispatcherServlet이 정적인 컨텐츠를 처리하도록 servlet-context.xml 파일 수정
		============================================================
		<mvc:resources location="WEB-INF/resources/" mapping="/resources/**" />
		============================================================	
		
		4) 정적인 컨텐츠가 정상적으로 화면에 포함된다.
		
	- 파일 업로드
		1) 파일 업로드 기능을 위해 MultipartResolver를 빈으로 등록한다. [servlet-context.xml]
		============================================================
		<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
			<property name="maxUploadSize" value="104857600" />
			<property name="defaultEncoding" value="UTF-8" />
		</bean>
		============================================================
		
		2) MultipartFile 업로드 기능을 위해 commons-fileupload를 pom.xml에 추가
		============================================================
		<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->
		<dependency>
			<groupId>commons-fileupload</groupId>
			<artifactId>commons-fileupload</artifactId>
			<version>1.3.3</version>
		</dependency>		
		============================================================
		
		3) 파일업로드를 위한 Controller 하나 추가
		============================================================		
		@Controller
		@RequestMapping("/bbs")
		public class FileUploadController {
		
			@RequestMapping("/upload")
			public String upload(
					@RequestParam("file") MultipartFile file,
					@RequestParam("name") String fileName,
					Model model) throws IllegalStateException, IOException {
				
				if(!file.isEmpty()) {
					//c디렉토리에 실제 파일명으로 저장한다.
					File tmpfile = new File("c:\\upload", file.getOriginalFilename());
					file.transferTo(tmpfile);
				}
				
				// 업로드한 파일명을 화면에 넘긴다.
				model.addAttribute("fileName", fileName);
				return "upload_ok";
			}
		}		
		============================================================
		
		4) 파일 업로드 테스트를 포스트맨으로 수행
		============================================================
		* Body -> form-data 옵션
			* key : file / type : file
			* key : name 
		============================================================


<2020-04-20 12강 JUnit4 & Spring-Test>
* JUnit 개요 : 
	- Java에서 독립된 단위테스트를 지원해주는 프레임워크이다.
	- Spring Container에 올라가 있는 Bean들을 테스트 해보자.

* 단위테스트(Unit Test) : 
	- 소스 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차, 즉 모든
	  함수와 메소드에 대한 테스트 케이스를 작성하는 절차를 말한다.
	- jUnit은 보이지 않고 숨겨진 단위 테스트를 끌어내고 정혀화시켜 
	  단위테스트를 쉽게 해주는 테스트 지원 프레임워크이다.

* JUnit의 특징
	- (assert) 메서드로 테스트 케이스의 수행 결과를 판결함
	  [assertEquals(예상값, 실제값)]
	- jUnit4부터는 테스트를 지원하는 어노테이션을 제공
	  [@Test @Before @After]
	- 각 @Test 메서드가 호출할 때 새로운 인스턴스를 생성하여 
	  독립적인 테스트가 이루어지도록 함

* jUnit에서 테스트를 지원하는 어노테이션
	- @Test
		- @Test가 선언된 메서드는 테스트를 수행하는 메소드 [단위 테스트 단위]
		- jUnit은 각각의 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 원칙으로 
		  하므로 @Test 마다 객체를 생성한다.
	- @Ignore : 
		- @Ignore가 선언된 메서드는 테스트를 실행하지 않게 한다.	
	- @Before : 
		- @Before가 선언된 메소드는 @Test 메소드가 실행되기 전에 반드시 실행된다.
		- @Test 메소드에서 공통으로 사용하는 코드를 @Before 메소드에 선언하여 사용
	- @After : 
		-  @After가 선언된 메서드는 @Test 메소드가 실행된 후 실행 [자원 반납 등]
	- @BeforeClass : 
		- @BeforeClass 어노테이션은 @Test 메소드 보다 먼저 한번만 수행되어야 할 경우에 사용하면 된다.
	- @AfterClass : 
		- @AfterClass 어노테이션은 @Test 메소드 보다 나중에 한번만 수행되어야 할 경우에 사용한다.

* 순서도
	1) @BeforeClass
	2) [@Before -> @Test -> @After] ...
	3) @AfterClass

* 테스트 결과를 확인하는 assert 메서드
	- assertEquals(a, b) : a와 b가 일치하는지 확인
	- assertSmae(a, b) : assertEquals 메서드는 두 객체의 값이 같은지 확인하고, 
	  assertSame 메서드는 두 객체의 레퍼런스가 동일한가를 확인한다. (==)
	- assertArrayEquals(a, b) : 배열 A와 B가 일치함을 확인
	- assertTrue(a) : 조건 A가 참인지 확인
	- assertNotNull(a) : 조건 A가 null이 아님을 확인
	
* Spring-Test : jUnit4를 사용하여 Spring을 테스트하기 쉽게 해주는 라이브러리
	- Spring-Test에서 테스트를 지원하는 어노테이션
	- @ContextConfiguration : 스프링 빈 설정 파일의 위치를 지정할 때 사용되는 어노테이션
	- @Autowired : 
		- 스프링 DI에서 사용되는 특별한 어노테이션
		- 해당 변수에 자동으로 빈을 매핑

* 실습
	- JUnit4 테스트
	1) JUnit 사용을 위해 Pom에 라이브러리 추가
	========================================================
	<!-- https://mvnrepository.com/artifact/junit/junit -->
	<dependency>
    	<groupId>junit</groupId>
    	<artifactId>junit</artifactId>
    	<version>4.12</version>
    	<scope>test</scope>
	</dependency>	
	========================================================
	
	2) 테스트할 소스와 동일한 패키지 구조를 src/test/java에 구현
	========================================================
	* kr.co.acomp.dao.ArticleDao.java를 테스트하고 싶으면
	* src/test/java 디렉토리에 kr.co.acomp.dao 패키지 생성 후
	* 테스트 대상 소스명 + Test 네이밍룰에 맞추어 class 생성
	* ArticleDaoTest.java
	
	* ArticleDao.java 파일의 selectArticleById 메소드를 테스트 할 경우
	* ArticleDaoTest.java 파일에 testSelectArticleById 메소드 생성
	========================================================	
	
	3) Assert 구문을 통해 단위테스트 성공 조건을 걸고, 화면에서 우클릭 -> Run as -> JUnit Test 실행
	========================================================
	@Test
	public void testSelectArticleById() {
		
		ApplicationContext ctx = new FileSystemXmlApplicationContext("file:src/main/webapp/WEB-INF/spring/servlet-context.xml");
		//DI
		ArticleDAO dao = ctx.getBean("articleDAO", ArticleDAO.class);
		
		Article article = dao.selectArticleById(null);
		Assert.assertTrue(article.getAuthor().equals("lee"));
	}	
	========================================================
	
	4) ApplicationContext를 띄우는 코드는 모든 테스트에 필요하다고 볼 수 있다. [@Before 사용]
	   [각각의 TestCase가 실행된 때마다 Before가 수행된다.]
	========================================================
	private ApplicationContext ctx; //클래스 변수로 빼고
	
	@Before
	public void setup() {
		ctx = new FileSystemXmlApplicationContext("file:src/main/webapp/WEB-INF/spring/servlet-context.xml");
	}
	========================================================	
	
	- Spring-Test
	1) Spring-Test 사용을 위한 Dependency 추가
	========================================================
	<!-- https://mvnrepository.com/artifact/org.springframework/spring-test -->
	<dependency>
   	 	<groupId>org.springframework</groupId>
    	<artifactId>spring-test</artifactId>
    	<version>4.3.26.RELEASE</version>
    	<scope>test</scope>
	</dependency>
	========================================================
	
	2) 기존의 테스트 코드를 Spring MVC에서 제공하는 DL/DI를 통해 변경 가능하다.
	========================================================
	/* AS-IS */
	public class ArticleDaoTest {
		
		private ApplicationContext ctx;
		
		@Before
		public void setup() {
			ctx = new FileSystemXmlApplicationContext("file:src/main/webapp/WEB-INF/spring/servlet-context.xml");
		}
		
		@Test
		public void testSelectArticleById() {
			
			ApplicationContext ctx = new FileSystemXmlApplicationContext("file:src/main/webapp/WEB-INF/spring/servlet-context.xml");
			//DI
			ArticleDAO dao = ctx.getBean("articleDAO", ArticleDAO.class);
			
			Article article = dao.selectArticleById(null);
			Assert.assertTrue(article.getAuthor().equals("lee"));
		}
	}	
	========================================================

	========================================================
	/* TO-BE */
	@RunWith(SpringJUnit4ClassRunner.class)
	@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/servlet-context.xml")
	public class ArticleDaoTest {
		
		@Autowired
		private ArticleDAO dao;
		
		@Test
		public void testSelectArticleById() {
			Article article = dao.selectArticleById(null);
			Assert.assertTrue(article.getAuthor().equals("lee"));
		}
	}	
	========================================================	
	
<2020-04-21 13강 Spring-Data Access 기술과 DataSource>
* DAO 디자인 패턴
	- 비즈니스 서비스와 로우레벨의 데이터 엑세스 작업을 분리
	- DAO 레이어 : 데이터베이스와 비즈니스 레이어 사이에 위치
	
* 데이터 엑세스 기술
	- JDBC : 
		- 자바에서의 관계형 데이터베이스 접속 기술
		- JDK 레벨에서 지원하며, 다른 고수준 기술의 기반이 된다.
	- Spring JDBC : 
		- 스프링 자체적으로 지원하는 JDBC Wrapper
	- MyBatis [java, sql의 분리] : 
		- Third-party 자바-관계형DB 매핑 라이브러리
		- 자바 오브젝트와 SQL문을 자동으로 매핑 - SQL Mapper

	- JPA : Java ORM 표준 인터페이스 
	  [자바 객체와 릴레이션을 자동으로 매핑하여, 자바객체로서 CRUD 작업을 진행]
	- Hibernate : 자바 ORM 구현체 [JPA를 실제로 구현한 것]

* Spring-JDBC와 MyBatis
	- 스프링 프레임워크에 포함된 스프링 공식 데이터베이스 연동 라이브러리
	- 유연한 Transaction 처리를 위해 Connection 단의 높은 추상화를 제공
	- Connection-Pool을 지원하고, Result Mapper의 추상화를 사용해 쿼리를 편리하게 수행할 수 있음
	- MyBatis, Hibernate 등이 Spring-JDBC를 사용 [MyBatis도 내부적으로는 Spring-JDBC를 사용한다.]
	
* MyBatis
	- XML을 별도 파일로 분리하고, 자바 객체와 SQL 매핑을 지원하는 프레임워크
	- 별도의 라이브러리로 존재하고 스프링과 연동 모듈을 지원한다.
		- mybatis-spring 라이브러리 필요
		- 스칼라 MyBatis, .NET MyBatis 등도 있다.

* DataSource [Spring에서는 DataSource 빈을 등록하여 사용한다.]
	- Connection 확보 - DB에 연결
	- 데이터소스는 Connection을 가져오기 위한 기술
	- 스프링은 DataSource를 통해 Connection을 제공
	
* DataSource 설정 방법
	- DriverManager를 사용하는 방법
		- DriverManagerDataSource 클래스를 사용
		- Connection Pool이나 JNDI를 사용할 수 없는 경우 사용
	- Connection Pool을 사용하는 방법
		- 데이터베이스 커넥션을 미리 여러 개를 확보해두고 클라이언트의 요청에 따라 제공하고 반납받는 시스템
		- 매번 물리적으로 커네셕을 생성하지 않아 성능이 좋아짐
		[tomcat과 같은 상용 WAS에도 Connection Pool을 지원한다.]

* 자주 바뀔 수 있는 정적인 설정정보를 주로 프라퍼티 파일로 별도 관리
	- 복잡하게 구성할 필요 없이, 키와 값의 쌍으로 구성

* 실습
	* DataSource 설정

	1) MyBatis를 사용한다고 해도 기반 기술은 spring-jdbc이기에 아래의 dependency 추가
	========================================================	
	<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
	<dependency>
    	<groupId>org.springframework</groupId>
    	<artifactId>spring-jdbc</artifactId>
    	<version>4.3.9.RELEASE</version>
	</dependency>
	========================================================

	2) Spring 설정파일에 DataSource 설정
	========================================================
	<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
		<property name="driverClass" value="com.sql.jdbc.Driver" />
		<property name="url" value="jdbc:mysql://localhost:3306/spring" />
		<property name="username" value="spring" />
		<property name="password" value="spring" />
	</bean>
	========================================================

	3) 프라퍼티의 값들을 별도의 파일로 분리해 보자
		- Maven 프로젝트의 classpath 루트는 src/main/resources 폴더이다.
	========================================================
	<context:property-placeholder location="classpath:config/database.properties"/>
	<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
		<property name="driverClass" value="${db.driverClass}" />
		<property name="url" value="${db.url}" />
		<property name="username" value="${db.username}" />
		<property name="password" value="${db.password}" />
	</bean>
	
	
	/* database.properties */
	db.driverClass=com.sql.jdbc.Driver
	db.url=jdbc:mysql://localhost:3306/spring
	db.username=spring
	db.password=spring
	========================================================

	4) 참고! MySQL DB를 사용할 경우, jdbc Driver사용을 위해 dependency 추가필요
	========================================================
	<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
	<dependency>
    	<groupId>mysql</groupId>
    	<artifactId>mysql-connector-java</artifactId>
    	<version>8.0.19</version>
	</dependency>	
	========================================================

<2020-04-21 14강 Context 분리와 전략>
************ MySQL 설치 ************
* 참고 : https://javacpro.tistory.com/70
* 참고 : 버전은 5.7버전으로 깔았음
* 설치 과정
	1) zip 파일 다운로드 후 적절한 곳에 압축 해제
	2) 환경변수 설정
	3) mysqld --initialize-insecure [mysql home디렉토리에 data 폴더 생성되는지 확인]
	4) net start mysql [실행]
	5) net stop mysql [종료]
	6) mysql -u root -p [접속 방법]
	   [root / root]
* DB설정
	1) 계정 생성 : GRANT ALL PRIVILEGES ON *.* TO 'spring'@'localhost' IDENTIFIED BY 'spring';
	   생성 확인 : SELECT * FROM mysql.user;
	2) spring / spring 계정으로 접속
	3) create database spring;
	4) spring 계정으로 spring db 접속
	5) db 사용

* DispatcherServlet은 기능에 따라 여러개를 설정할 수 있다. 예를 들어 API서비스를 
  위한 DispatcherServlet을 별도로 설정해서 사용하는 것이 대표적이다.

* Servlet context vs Root Application context
	- 웹의 기능 + API를 위해 2개의 DispatcherServlet을 사용할 경우 2개의 context를
	  사용하는 것이고, 2개의 Bean Container를 별도로 사용하는 것이다.
	  복수개의 Servlet Context에서 공통적으로 접근할 수 있는 Root Context 개념을 도입한다.
	  
	- servlet context : 지금까지 해왔던 것
		- DispatcherServlet - 웹의 요청을 최초로 접수
		- DispatcherServlet - 설정 파일을 이용해서 ServletContext(스프링 컨테이너) 로딩
		- Spring-MVC와 관련 있는 빈을 설정
		
	- Root context : 
		- Spring-MVC와 분리되어 빈을 관리하고 싶을때 사용
		- 일반적으로 Servlet context와 Root context를 분리하여 운용

* Spring MVC에서 컨텍스트 계층 구조
	- ServletContext에서는 Root Context의 빈을 참조할 수 있다.
	  [ServletContext에서 우선 찾고 없으면 RootContext 참조]
	  [RootContext에서는 ServletContext 빈을 참조 불가]
	- 모든 Controller는 ServletContext에 설정
	  [Controller / ViewResolver / HandlerMapping]
	- Root Context에는 처리 로직을 설정
	  [Service / Reposiroty]

* Root Context 설정 - web.xml

* Root Application Context : 
	- 전체 컨텍스트 계층 구조에서 최상단에 위치
	- 서로 다른 서블릿 컨텍스트에서 공유해야 하는 Bean들을 등록해놓고 사용
	- 웹 어플리케이션 전체에 적용 가능한 DB연결 / 로깅 기능에 이용
	- Servlet Context에 등록된 Bean 이용 불가능
	- Servlet Context와 동일한 Bean이 있을 경우 Servlet Context Bean이 우선된다.
	- 하나의 컨텍스트에 정의된 AOP 설정은 다른 컨텍스트의 빈에는 영향을 미치지 않음

* Servlet Context : 
	- 서블릿에서만 이용되는 컨텍스트
	- 타 서블릿과 공유하기 위한 Bean들은 루트 컨텍스트에 등록하고 사용해야 함
	- DispatcherServlet은 자신만의 컨텍스트를 생성, 초기화하고 동시에
	  루트 어플리케이션 컨텍스트를 찾아서 자신의 부모 컨텍스트로 사용
	  
* 컨텍스트 분리 전략
	- Servlet Context
		- @Controller 어노테이션만 등록하겠다.
		============================================================
		<context:component-scan base-package="kr.co.acomp" use-default-filters="false">
			<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" />
		</context:component-scan>
		============================================================
		
	- Root Context [Controller 제외하고 등록하겠다.]
		- @Service 
		- @Repository
		============================================================
		<context:component-scan base-package="kr.co.acomp">
			<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" />
		</context:component-scan>
		============================================================		
		
* 컨텍스트에 로딩된 빈 확인
	- Spring Explorer 뷰를 통해 각각의 컨텍스트에 등록된 빈을 확인할 수 있다.

* 실습
	- Context 파일분리 : servlet-context.xml / root-context.xml
	
	1) web.xml 구문 추가
	============================================================
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/root-context.xml</param-value>
	</context-param>		
	============================================================	
	
	2) root-context.xml 파일 생성
	============================================================	
	* 경로 : /WEB-INF/spring/root-context.xml
	* Namespace에서 context 선택해 준다.
	============================================================		
	
	3) servlet-context.xml에 있던 Repository 설정을 옮겨 보자
	   아래의 구문을 이관
	============================================================	
	<context:property-placeholder location="classpath:config/database.properties"/>
	
	<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
		<property name="driverClass" value="${db.driverClass}" />
		<property name="url" value="${db.url}" />
		<property name="username" value="${db.username}" />
		<property name="password" value="${db.password}" />
	</bean>	
	============================================================	
	
	4) servelt-context에는 Controller만 있도록 설정하자 [완성본]
	- root-context.xml
	============================================================
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">
	
		<context:component-scan base-package="kr.co.acomp">
			<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" />
		</context:component-scan>
	
		<context:property-placeholder location="classpath:config/database.properties"/>
		
		<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
			<property name="driverClass" value="${db.driverClass}" />
			<property name="url" value="${db.url}" />
			<property name="username" value="${db.username}" />
			<property name="password" value="${db.password}" />
		</bean>
	
	</beans>
	============================================================

	- servlet.context.xml
	============================================================
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd
			http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">
	
	
		<context:component-scan base-package="kr.co.acomp" use-default-filters="false">
			<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
		</context:component-scan>
		<mvc:annotation-driven/>
		
		<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<property name="prefix" value="/WEB-INF/views/" />
			<property name="suffix" value=".jsp" />
		</bean>
		
		<mvc:resources location="WEB-INF/resources/" mapping="/resources/**" />
		
		<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
			<property name="maxUploadSize" value="104857600" />
			<property name="defaultEncoding" value="UTF-8" />
		</bean>
		
	</beans>
	============================================================	
	
	- 여러개의 root context 사용 예제
	1) web.xml에서 여러개의 root context 설정 가능
	- AS-IS
	============================================================	
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/root-context.xml</param-value>
	</context-param>	
	============================================================	
	-TO-BE
	============================================================	
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>
			/WEB-INF/spring/root-context.xml
			/WEB-INF/spring/datasource.xml
		</param-value>
	</context-param>
	============================================================
	
	2) datasource.xml 파일 생성
	3) root-context.xml 파일에 있던 dataSource관련 문구를 이관
	============================================================
	<context:property-placeholder location="classpath:config/database.properties"/>
	
	<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
		<property name="driverClass" value="${db.driverClass}" />
		<property name="url" value="${db.url}" />
		<property name="username" value="${db.username}" />
		<property name="password" value="${db.password}" />
	</bean>
	============================================================	
	
	4) Spring Explorer 뷰에서 dataSource관련 빈이 옮겨간 것을 확인할 수 있다.

	
<2020-04-23 15강 MyBatis 소개>
* MyBatis 개요
	- 자바 오브젝트와 SQL 사이의 자동 매핑 기능을 지원하는 Object Mapper
	- MyBatis는 SQL을 별도의 파일로 분리해서 관리하게 해주며, 객체-SQL 사이의
	  파라미터 Mapping 작업을 자동으로 해준다.
	- MyBatis는 Hibernate나 JAP(Java Persistence Api)처럼 새로운 DB
	  프로그램밍 패러다임을 익혀야 하는 부담이 없이, 개발자가 익숙한 SQL을 그대로 이용하면서
	  JDBC 코드 작성의 불편함도 제거해주고, 도메인 객체나 VO객체를 중심으로 개발이 가능하다는
	  장점이 있다.

* MyBatis의 특징
	- 쉬운 접근성과 코드의 간결함
		- 가장 간단한 퍼시스턴스 프레임워크
		- XML 형태로 서술된 JDBC 코드라고 생각해도 될 만큼 JDBC의
		  모든 기능을 MyBatis가 대부분 제공한다.
		- 복잡한 JDBC 코드를 걷어내며 깔끔한 소스코드를 유지할 수 있다.
		- 수동적인 파라미터 설정과 쿼리 결과에 대한 맵핑 구문을 제거할 수 있다.
	- SQL문과 프로그래밍 코드의 분리
		- SQL에 변경이 있을 때마다 자바 코드를 수정하거나 컴파일 하지 않아도 된다.
		- SQL 작성과 관리 또는 검토를 DBA와 같은 개발자가 아닌 다른 사람에게 맡길 수도 있음
	- 다양한 프로그래밍 언어로 구현 가능

* MyBatis와 MyBatis-Spring을 사용한 DB액세스 Architecture

* MyBatis3의 주요 컴포넌트
	- SqlSessionFactoryBuilder / SqlSessionFactory / SqlSession
	
* 주요 컴포넌트의 역할
	- MyBatis 설정파일 : 데이터베이스의 접속 주소 정보나 Mapping 파일의 경로 등의 고정된 환경정보
	- SqlSessionFactoryBuiler : MyBatis 설정 파일을 바탕으로 SqlSessionFactory를 생성
	- SqlSessionFactory : SqlSession을 생성
	- SqlSession : 핵심적인 역할을 하는 클래스로서 SQL실행이나 트랜잭션 관리를 실행
				   SqlSession 오브젝트는 Thread-Safe 하지 않으므로 thread마다 필요에 따라 생성한다.

* MyBatis-Spring의 주요 컴포넌트
	- SqlSessionFactoryBean : MyBatis 설정파일을 바탕으로 SqlSessionFactory를 생성
							  Spring Bean으로 등록해야 한다.
	- SqlSessionTemplate : 핵심적인 역할을 하는 클래스로서 SQL 실행이나 트랜잭션 관리를 실행
						   SqlSession 인터페이스를 구현하며, Thread-safe하다.
						   Spring Bean으로 등록해야 한다.

* 실습
	- mybatis, mybatis-spring 의존성 추가
		-> MyBatis / MyBatis-Spring 2개
	============================================================	
	<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
	<dependency>
    	<groupId>org.mybatis</groupId>
    	<artifactId>mybatis</artifactId>
    	<version>3.4.4</version>
	</dependency>

	<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
	<dependency>
    	<groupId>org.mybatis</groupId>
   	 	<artifactId>mybatis-spring</artifactId>
    	<version>1.3.1</version>
	</dependency>
	============================================================
	
	- mybatis 메인설정파일, mybatis-config.xml 설정
		- mybatis 설정파일 예시에는 다양한 설정이 있는데
		  대부분의 설정은 Mybatis-spring 설정파일에 포함될 것이므로
		  지워주면 된다.
	============================================================
	* 보통 classpath에 생성 [src/main/resources]
	* 형식이 매우 중요하기 때문에 템플릿을 다운 받는다.
		- https://mybatis.org/mybatis-3/ko/index.html
		- 시작하기 -> 메일 설정파일의 예제를 찾는다.
		
	<?xml version="1.0" encoding="UTF-8" ?>
	<!DOCTYPE configuration
	PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-config.dtd">
	<configuration>
	<environments default="development">
		<environment id="development">
		<transactionManager type="JDBC"/>
		<dataSource type="POOLED">
			<property name="driver" value="${driver}"/>
			<property name="url" value="${url}"/>
			<property name="username" value="${username}"/>
			<property name="password" value="${password}"/>
		</dataSource>
		</environment>
	</environments>
	<mappers>
		<mapper resource="org/mybatis/example/BlogMapper.xml"/>
	</mappers>
	</configuration>
	
	============================================================		
	<?xml version="1.0" encoding="UTF-8" ?>
	<!DOCTYPE configuration
	PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
	"http://mybatis.org/dtd/mybatis-3-config.dtd">
	<configuration>

	</configuration>
	============================================================	
	
	- sqlSessionFactory, sqlSession 설정 [가장 중요함]
	============================================================	
	* mybatis도 결국 datasource를 사용해야 하기 때문에 datasource를 설정한
	  datasource.xml파일에 설정을 추가한다.


	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="configLocation" value="classpath:config/mybatis-config.xml" />
		<property name="mapperLocations" >
			<list>
				<value></value>
			</list>
		</property>
	</bean>	
	
	<bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
		<constructor-arg ref="sqlSessionFactory" />
	</bean>
	============================================================	
	
	- 매퍼 파일 설정
	============================================================
	* Mapper파일을 저장할 디렉토리는 보통 classpath에 지정
		-> src/main/resources/mappers
		-> 매퍼 파일은 DAO와 1:1 매핑을 기본적으로 사용한다.
	* Mapper를 작성을 도와주는 이클립스 플러그인이 있다.
		-> Eclipse Marketplaces
		-> mybatis 검색
		-> MyBatipse 설치
		-> mapper.xml 파일을 만들때, 파일타입이 생긴다.
		   [new -> other -> MyBatis -> MyBatis XML Mapper]
		   
	* Mapper를 하나 생성해 보자 : article-mapper.xml
	* datasource.xml파일의 mapperlocations 프라퍼티에 등록
	============================================================	
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="configLocation" value="classpath:config/mybatis-config.xml" />
		<property name="mapperLocations" >
			<list>
				<value>classpath:mappers/article-mapper.xml</value>
			</list>
		</property>
	</bean>	
	
	<bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
		<constructor-arg ref="sqlSessionFactory" />
	</bean>
	============================================================


<2020-04-24 16강 Mapper XML 파일>
* Mapper XML 파일
	- sql문을 저장하는 존재를 매핑파일이라고 함
	- JDBC 코드에 비해 코드수가 95% 이상 감소하기도 함
	- MyBatis는 SQL 작성에 집중할 수 있도록 만들어짐

* XML 매퍼 작성
	- DAO 클래스가 작성되면 이를 사용하는 SQL문 작성 필요
	- 작성 순서
		- XML로 작성된 Mapper의 위치를 결정
		- XML Mapper 파일을 작성하고 필요한 DTD 추가 (템플릿 파일 사용)
		- SQL 작성
		
* Select
	- Mybatis에서 가장 많이 사용하는 엘리먼트
	- 어플리케이션은 데이터를 수정하는 기능보다 데이터 조회를 주로 함
	- Mybatis는 데이터를 조회하는 기능에 집중함
	
* select 엘리먼트 세부 속성
	- id
	- parameterType
	- parameterMap ="deprecated"
	- resultType
	- resultMap
	- flushCache
	- useCache
	- timeout
	- fetchSize
	- statementType

* MS-SQL, MySQL의 경우 KeyProperty 설정

* Parameters
	- 전달되는 객체에 따라 파라미터의 타입이 결정된다.
	- parameterType="Full-Package Name of VO"
	
* Result Maps
	- Mybatis에서 가장 중요하고 강력한 요소
	- 데이터베이스에서 데이터를 가져올 때 작성되는 JDBC코드를 대부분 줄여주는 역할
	- 반환되는 값이 VO의 속성명과 다를 경우, resultMap에 컬럼과 프라퍼티명을 새로
	  매핑해서 사용할 수 있다.

* MyBatis로깅::log4jdbc-log4j2
	- MyBatis의 로그를 보다 자세히 확인 가능하게 해줌
	  [Log4jdbc-log4j2 라이브러리 의존성 추가]
	- datasource  변경
		- driverClass의 이름을 net.sf.log4jdbc.DriverSpy
		- 연결 URL 중간에 log4jdbc라는 단어 추가
		- log4jdbc.log4j2.properties 파일 추가
	=======================================================================
	<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
		<property name="driverClass" value="${db.driverClass}" />
		<property name="url" value="${db.url}" />
		<property name="username" value="${db.username}" />
		<property name="password" value="${db.password}" />
	</bean>
	
	
	<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
		<property name="driverClass" value="net.sf.log4jdbc.sql.jdbcapi.DriverSpy" />
		<property name="url" value="jdbc:log4jdbc:mysql://127.0.0.1:3306/spring" />
		<property name="username" value="${db.username}" />
		<property name="password" value="${db.password}" />
	</bean>
	=======================================================================

* 실습
	- article-mapper.xml 구현
	- 쿼리의 ID값은 Mapper파일의 namespace와 결합하여 유일해야 한다.
	
	- DAO에서 sql ID값과 autowired 주의
	=======================================================================
	@Autowired
	SqlSession sqlSession;

	public void insertArticle(Article article) {
		sqlSession.insert("mappers.article-mapper.insertArticle", article);
	}

	public Article selectArticleById(String articleId) {
		return sqlSession.selectOne("mappers.article-mapper.selectArticleById", articleId);
	}
	=======================================================================

	=======================================================================
	<insert id="insertArticle" parameterType="kr.co.acomp.vo.Article">
		insert into (article_id, author, title, content)
		values (#{articleId}, #{author}, #{title}, #{content})
	</insert>

	<select id="selectArticleById" parameterType="string" resultType="kr.co.acomp.vo.Article">
		select 
			  article_id as articleId
			, author
			, title
			, content 
		from article
		where article_id = #{articleId}
	</select>
	=======================================================================


<2020-04-25 17강 Dynamic SQL>
* Dynamic SQL : 
	- 검색 조건에 따라 검색해야 하는 SQL문이 달라지기 때문에 이를 처리하기 위해 사용

* MyBatis의 표현식 : 
	- if
	- choose(when, otherwise)
	- trim(where, set)
	- foreach
	
* 동적 SQL 작성 유의사항
		- SQL문이 실행 시에 변경되기 때문에 모든 케이스에  대해 테스트가 이루어져야 함
		- 동적 SQL문이 없는 상태에서 정상적인 실행을 확인 후, 동적 SQL을 추가해서 개발

* if : 
	=======================================================================
	<if test="title != null">
		AND title like #{title}
	</if>
	
	<if test="author != null and author.name != null">
		AND author_name like #{author.name}
	</if>	
	=======================================================================
	- 클래스 내부의 멤버변수는 dot 연산자로 접근 가능
	
* choose(when, otherwise) : 조건 중 1개를 선택

* trim(where, set) : 
	=======================================================================
	SELECT * FROM BLOG
	<trim prefix="WHERE" prefixOverrids="AND">
		<if test="title != null">
			state = #{state}
		</if>
		<if test="title != null">
			title like #{title}
		</if>
	</trim>
	=======================================================================	
	
	=======================================================================	
	<trim prefix="SET" suffixOverrides=",">
		update Author
		<trim prefix="SET" suffixOverrides=",">
			<if test="title != null">
				state = #{state}
			</if>
			<if test="title != null">
				title = #{title}
			</if>
		</trim>
	=======================================================================	

* foreach : 반복 처리 기능 [in 키워드를 사용할때 종종 사용]
	=======================================================================	
	SELECT * FROM POST P WHERE ID IN
	<foreach item="item" index="index" collection="list" 
			open="(" separator="," close=")">
		#{item}
	</foreach>
	=======================================================================	
	- collection 속성 : list일 경우 list, array일 경우 array

* 실습
	- article-mapper.xml 테스트
	=======================================================================	
	* MySQL 처음 사용할때, 캐릭터셋 및 타임존 설정을 해주어야 한다.
	  [안되어 있으면 에러남]
	* 임시방편으로 Spring에서 연결할때 아예 변수로 주는 방법을 썻다.
		db.driverClass=com.mysql.jdbc.Driver
		db.url=jdbc:mysql://localhost:3306/spring?characterEncoding=UTF-8&serverTimezone=UTC
		db.username=spring
		db.password=spring
		
		
	// mapper insert 테스트
	@RequestMapping(value="/insertArticle", method=RequestMethod.GET)
	public String write10() {
		service.registArticle(new Article(2, "kim", "test", "fucking test"));
		return "write";
	}
	
	// mapper select 테스트
	@RequestMapping(value="/selectArticle", method=RequestMethod.GET)
	public ModelAndView selectArticle() {
		Article article = service.viewArticleDetail("1");
		return new ModelAndView("write").addObject("article", article);
	}	
	=======================================================================	
	
	- dynamic query 예제
	=======================================================================	
	* resultMap 예제 :  
		- 아래의 예제에서 id는 키값을, result는 일반 컬럼을 의미
		- ClubVO 객체는 멤버 변수로 memberVO라는 객체를 가지고 있다고 생각하면 쉽다.
		
	<resultMap type="kr.co.acomp.ClubVO" id="clubMap">
		<id cloumn="AR_ID" property="articleId" />
		<result cloumn="AR_ID1" property="articleId1" />
		<result cloumn="AR_ID2" property="articleId2" />
		<result cloumn="AR_ID3" property="articleId3" />
		<association property="memberVO" javaType="kr.co.acomp.vo.MemberVO">
			<id		/>
			<result	/>
			<result	/>
		</association>
	</resultMap>
	=======================================================================	


<2020-04-25 18강 Aspect Oriented Programming>
* AOP 개요 [스프링의 3대 기능 중 하나]
	- 핵심기능과 부가기능
		- 업무로직을 포함하는 기능을 핵심기능 (core Concerns)
		- 핵심기능을 도와주는 부가적인 기능(로깅, 보안)을 부가기능 (Cross-cutting Concerns)
		- 객체지향의 기본 원칙을 적용하여도 핵심기능에서 부가기능을 분리해서 모듈화하는 것은 어렵다.
		
* AOP는 애플리케이션에서의 관심사의 분리(기능의 분리) 즉, 핵심적인 기능에서
  부가적인 기능을 분리. 분리한 부가기능을 Aspect라는 독특한 모듈형태로 만들어서 설계하고 개발하는 방법
	- OOP를 적용하여도 핵심기능에서 부가기능을 쉽게 분리된 모듈로
	  작성하기 어려운 문제점을 AOP가 해결해 준다고 볼 수 있다.

* Aspect
	- Aspect는 부가기능을 정의한 코드인 Advice와 어드바이스를 어디에
	  적용할지를 결정하는 포인트컷(PointCut)을 합친 개념이다.
	- AOP 개념을 적용하면 핵심기능 코드 사이에 침투된 부가기능을 
	  독립적인 애스펙트로 구분해 낼 수 있다.
	- 구분된 부가기능 에스펙트를 런타임 시에 필요한 위치에 독적으로 참여하게 할 수 있다.
	
* AOP 용어 : 
	- Tarket : 핵심기능을 담고 있는 모듈로, 타깃은 부가기능을 부여할 대상이 됨
	- Advice : 어드바이스는 타깃에 제공할 부가기능을 담고 있는 모듈
	- Join Point : 어드바이스가 적용될 수 있는 위치를 말한다.
	- Pointcut : 어드바이스를 적용할 타깃의 메서드를 선별하는 정규표현식
				 포인트컷 표현식은 exexution으로 시작하고, 메서드의 Signature를 비교하는 방법을 이용
	- Aspect : 에스펙트는 AOP의 기본 모듈
	           에스펙트 = 어드바이스 + 포인트컷
			   에스펙트는 싱글톤 형태의 객체로 존재함
	- Advisor : 어드바이저는 에스펙트와 동일한 용어로 SpringAOP에서만 사용되는 특별한 용어이다.
	  [AOP : JAVA에서는 AspectJ를 통해 사용, Spring에서는 SpringAOP를 사용한다.]
	- Weaving : 
		- 위빙은 포인트컷에 의해서 결정된 타깃의 조인 포인트에
	      부가기능(어드바이스)를 삽입하는 과정을 의미한다.
		- 위빙은 AOP가 핵심기능(타깃)의 코드에 영향을 주지 않으면서 필요한
		  부가기능(어드바이스)을 추가할 수 있도록 해주는 핵심적인 처리과정

* Spring AOP의 특징 : 
	- Spring은 프록시(Proxy) 기반 AOP를 지원한다.
	- Spring은 타겟 객체에  대한 프록시를 만들어 제공
	- 타깃을 감싸는 프록시는 Runtime에 생성된다.
	- 프록시는 어드바이스를 타깃 객체에 적용하면서 생성되는 객체이다.
	
	- 프록시가 호출을 가로챈다. [Intercept]
	- 프록시는 타깃 객체에 대한 호출을 가로챈 다음 어드바이스의 부가기능
	  로직을 수행하고 난 후에  타깃의 핵심기능 로직을 호출 
	  [전처리 어드바이스]
	- 타깃의 핵심기능 로직 메서드를 호출한 후에 부가기능(어드바이스)을 수행하는 경우도 있다.
      [후처리 어드바이스]
	  
	- Spring AOP는 메서드 조인 포인트만 지원한다.
	- Spring은 동적 프록시를 기반으로 AOP를 구현하므로 메서드 조인 포인트만 지원함
	- 즉, 핵심기능(타깃)의 메서드가 호출되는 런타임 시점에만 부가기능(어드바이스)를 적용할 수 있다.
	- 반면에 AspectJ 같은 고급 AOP 프레임워크를 사용하면 객체의 생성,
	  필드값의 조회와 조작, static 메서드 호출 및 초기화 등의 다양한 작업에 부가기능을 적용할 수 있다.

* 실습
	1) 의존성 설치 [2개] : spring-aop, aspectj weaver
	=======================================================================
	<!-- https://mvnrepository.com/artifact/org.springframework/spring-aop -->
	<dependency>
    	<groupId>org.springframework</groupId>
    	<artifactId>spring-aop</artifactId>
    	<version>4.3.26.RELEASE</version>
	</dependency>

	<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
	<dependency>
    	<groupId>org.aspectj</groupId>
    	<artifactId>aspectjweaver</artifactId>
    	<version>1.8.10</version>
	</dependency>
	=======================================================================
	
	2) AOP 자동 프록시 설정 : root-context.xml [네임스페이스 추가!]
	=======================================================================
	<aop:aspectj-autoproxy />
	=======================================================================
	
	3) SampleAspect 생성
		- Aspect 클래스 또한 빈으로 등록된다.
	=======================================================================
	package kr.co.acomp.aspect;
	
	import org.aspectj.lang.JoinPoint;
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Before;
	import org.springframework.stereotype.Component;
	
	@Component
	@Aspect
	public class SampleAspect {
	
		//전처리 어드바이스(포인트컷) kr.co.acomp 패키지 밑에 있는 모든 클래스의 모든 메소드에 대응하여 호출한다.
		//root-context.xml에서 프록시를 설정했기 때문에 controller를 제외한 메서드에만 적용된다.
		@Before("execution(* kr.co.acomp..*.*(..))")
		public void before(JoinPoint joinPoint) {
			String targetMethodName = joinPoint.getSignature().getName();
			
			System.out.println(targetMethodName + " is invoked");
		}
	}
	=======================================================================
	
	- AOP를 Controller를 제외한 모든 메서드에 적용하고 
	  조회 화면을 들어가면 아래와 같이 메서드명이 console에 찍힌다.
	=======================================================================
	정보: FrameworkServlet 'dispatcherServlet': initialization completed in 4297 ms
	viewArticleDetail is invoked
	selectArticleById is invoked
	=======================================================================


<2020-04-26 19강 PointCut 표현식과  Advisor 구현>
* PointCut 표현식 문법
	- AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용하여 작성함
	- 포인트컷 지시자 중에서 가장 대표적으로  사용되는 것은 execution()
	
* PointCut 표현식 예시
	- "execution(* aspects.trace.demo.*.*(..))"
		- * : Any return type
		- aspects.trace.demo : package
		- .* :  class
		- .* : method
		- (..) : Any type and number of arguments
		
	- execution(* hello(..)) : hello라는 이름을 가진 메서드를 선정 [파라미터는 모든 종류 허용]
	- execution(* hello()) : hello 메서드 중에서 파라미터가 없는 것만 선택
	- execution(* myspring.user.service.UserServiceImpl.*(..))
		- myspring.user.service.UserServiceImpl 클래스의 모든 메서드
	- execution(* myspring.user.service.*.*(..))
		- myspring.user.service 패키지의 모든 클래스에 적용
		  하지만 서브패키지의 클래스는 포함되지 않는다. [서브패키지를 포함하려면 아래와 같이 작성]
		  [execution(* myspring.user.service..*.*(..))]
	- execution(* myspring.user.service..*.*(..))
		- myspring.user.service 패키지의 모든 클래스에 적용 [서브패키지 포함]
	- execution(* *..Target.*(..))
		- 패키지에 상관없이 Target이라는 이름의 모든 클래스에 적용
		- 다른 패키지에 같은 이름의 클래스가 있어도 적용이 된다는 점에 유의

* Spring AOP 구현방식
	- XML 기반의 POJO 클래스를 이용한 AOP 구현 : 
		- 부가기능을 제공하는 Advice 클래스를 작성
		- XML 설정 파일에 <aop:config>를 이용하여 에스펙트를 설정함
		  [트랜잭션 어드바이스와 같이 내장된 어드바이스를 사용할때 주로 사용한다.]
	- @Aspect 어노테이션을 이용한 AOP 구현
		- @Aspect 어노테이션을 이용해서 부가기능을 제공하는 Aspect 클래스를 작성
		- Aspect 클래스는 어드바이스를 구현하는 메서드와 포인트컷을 포함
		- XML 설정 파일에 <aop:aspectj-autoproxy /> 설정
		  [사용자가 직접 작성하는 어드바이스를 사용할때 주로 사용한다.]

* @Aspect 어노테이션 : 
	- Aspect 클래스를 선언할 때 @Aspect 어노테이션을 사용
	- AspectJ 5버전에  새롭게 추가된 어노테이션
	- @Aspect 어노테이션을 이용할 경우 XML 설정 파일에 
	  어드바이스와 포인트컷을 설정하는 것이 아니라 클래스 내부에 정의할 수 있다.
	- <aop:aspectj-autoproxy> 태그를 설정파일에 추가하면 @Aspect
	  어노테이션이 적용된 Bean을 Aspect로 사용 가능하다.
	  
* Advice 종류
	- Around Advice : 
		- 타깃의 메서드가  호출되기  이전 시점과 이후 시점에 모두 처리해야 할 필요가 있는 부가기능 정의
		- JoinPoint 앞과 뒤에서 실행되는 Advice
	- Before Advice : 
		- 타깃의 메서드가 실행되기 이전 시점에 처리해야 할 필요가 있는 부가기능을 정의
		- JoinPoint 앞에서 실행되는 Advice
	- After Returning Advice : 
		- 타깃의 메서드가 정상적으로 실행된 이후 시점에 처리해야 할 필요가 있는 부가기능을 정의
		- JoinPoint 메서드 호출이 정상적으로 종료된 뒤에 실행되는 Advice
	- After Throwing Advice : 
		- 타깃의 메서드가 예외를 발생된 이후 시점에  처리해야 할 필요가 있는 부가기능을 정의
		- 예외가 던져질 때 실행되는 Advice

* Advice를 정의하는 어노테이션 : 
	- Advice를 정의하기 위해 아래와 같은 어노테이션을 제공
	- @Before("pointcut") : 
		- 타깃 객체의 메서드가 실행되기 전에 호출되는 어드바이스
		- JoinPoint를 통해 파라미터 정보를 참조할 수 있음
	- @After("pointcut") :
		- 타깃 객체의 메서드가 정상 종료됐을 때와 예외가 발생했을 때 모두 호출되는 어드바이스
		- 리턴값이나 예외를 직접  전달받을 수는 없음
	- @Around("pointcut") : 
		- 타깃 객체의 메서드가 호출되는 전 과정을 모두 담을 수 있는 가장 강력한 기능을 가진 어드바이스
	- @AfterReturning(pointcut="", returning="") : 
		- 타깃 객체의 메서드가 정상적으로 실행을 마친 후에 호출되는 어드바이스
		- 리턴값을 참조할 때는 returning 속성에 리턴값을 저장할 변수 이름을 지정해야 한다.
	- @AfterThrowing(pointcut="", throwing="") : 
		- 타깃 객체의 메서드가 예외가 발생하면 호출되는 어드바이스
		- 발생된 예외를 참조할 때는 throwing 속성에 발생한 예외를 저장할 변수 이름을 지정해야 한다.
		
* JoinPoint 인터페이스 : 
	- AOP가 적용되는 지점
	- 주요 메서드
		- getArgs() : 메서드 아규먼트를 반환한다.
		- getThis() : 프록시 객체를 반환한다.
		- getTarget() : 대상 객체를 반환한다.
		- getSignature() : 어드바이즈 되는 메서드의 설명을 반환한다.
		- toString() : 어드바이즈 되는 메서드의 설명을 출력한다.
	
	- 모든 어드바이스는 org.aspectj.lang.JoinPoint 타입의 파라미터를 어드바이스 
	  메서드에 첫 번째 매개변수로 선언할 수 있다.
	- Around 어드바이스는 JoinPoint의 하위 클래스인 
	  ProceedingJoinPoint 타입의 파라미터를 필수적으로 선언해야 한다.
		- proceed() : 타깃 메소드를 실행시키는 구문
		- Around 어드바이스의 대표적인 예 : 메소드의 실행시간 체크
		
* 실습 : 
	1. 메소드 실행시간 확인 Aspect 생성
		- MeasuringAspect
		- @Around 어드바이스 활용
	=======================================================================		
	@Around("execution(* kr.co.acomp.service.*Service.*(..))")
	public Object measuringMethodRunningTime(ProceedingJoinPoint joinPoint) throws Throwable {
		//메서드 실행전 로직부
		long start = System.currentTimeMillis();
		
		try {
			//메서드 실행
			return joinPoint.proceed();
		}  finally {
			//메서드  실행 후 로직부
			long result = System.currentTimeMillis() - start;
			String targetMethodName = joinPoint.getSignature().getName();
			System.out.println(targetMethodName + " Running time is : " + result);
		}
	}

	-> viewArticleDetail Running time is : 1437
	=======================================================================	


<2020-04-26 20강 트랜잭션과 로깅>
* 스프링 트랜잭션 : 
	- 선언적 트랜잭션 : 스프링은 선언적 트랜잭션 방식을 사용
		- 어노테이션을 이용한 선언적 방식
		- AOP를 이용한 선언적 방식
	- 프로그램에 의한 트랜잭션 처리 (권장되지 않음)
	- 스프링에서 트랜잭션 처리 모범사례
		- 선언적 방식에 의한 트랜잭션 처리
		- 트랜잭션은 주로 서비스 메소드를 대상으로 한다. [비지니스 로직을 포함]
		
* 어노테이션에 의한 트랜잭션 : 
	- @root-context.xml에 Transaction Manager를 설정
		- 트랜잭션 메니저 빈 설정
		- <tx:annotation-driven .../> 
	- 트랜잭션이 필요한 클래스나 메소드에 @Transactional 어노테이션 추가
	  [필요한 모든 메소드에 어노테이션을 추가하는 작업도 불편하다!!!!! -> AOP를 이용]
	- 주로 서비스 클래스의 메소드에 적용

* AOP를 이용한 트랜잭션 : 소스코드 변경없이 타겟 메소드 지정 가능
	- 트랜잭션 매니저 설정
	- 트랜잭션 어드바이스 설정 : 스프링 내장 어드바이스
	- AOP 설정 : XML을 통한 Aspect 정의 사용

* SLF4J와 Logback을 이용한 로그 남기기
	- JAVA진영에는 많은 로깅툴이 존재한다.
		- commons-logging
		- log4j
		- java util logging
		- logback
	
	- 이전에는 log4j와 commons-logging이 주로 사용되었고, Spring 또한
	  commons-logging을 사용해 로그를 남기고 있다.
	  
	- 하지만 SLF4J가 나온 이후 많은 오픈소스 프로젝트가 SLF4J를 선택하고 있고,
	  그 비중은 점점 커져가고 있다.

	- 여러 오픈소스 프로젝트를 사용하다 보면 Logging Tool이 혼재되어 충돌이 되는 경우가
	  빈번한데, 이럴 경우 Logging Tool을 통일시켜 주어야 한다.
	
	- 가장 최근에 나오고 가장 많이 사용되고 있는 SLF4J, Logback으로 통일함
	  [SLF4J : 로깅을 위한 I/F. 그 구현체로 Logback을 사용해 보겠다는 의미]
	  
* SLF4J, LogBack Dependency 추가
	- Spring에서 이미 사용중인 <commons-logging>을 제외하는 작업
	- <slf4j-api> 디펜던시 추가
	- <jcl-over-slf4j> 디펜던시 추가
	- <logback-classic> 디펜던시 추가
	
* LogBack 설정 
	- src/main/resources : classpath에 logback.xml 파일 생성 [방식은 log4j와 유사]
	- Logback log  level
		- TRACE - DEBUG - INFO - WARN - ERROR
		  [TRACE는 TRACE, DEBUG, INFO, WARN, ERROR 레벨을 모두 포함한다.]
	- logback.xml 파일명 변경 및 적용
		- Logback은 기본 설정파일로 lobback.xml을 필요로 한다. 스프링은 이런 기본설정을
		  Listener를 통해서 변경이 가능하도록 지원해주는데, Logback의 경우 "logback-ext-spring"을 필요로 한다.
		- 운영기에서 적용되는 설정 파일은 logback.xml 파일이지만, 개발시에만
		  적용시킬 별도의 logback 설정파일을 등록하고 싶을때 주로 사용
			- <logback-ext-apring> dependency 추가
			- web.xml 수정

* 실습 : 
	1) 트랜잭션 설정
	=======================================================================	
	(1) datasource.xml 파일에 DataSourceTransactionManager bean등록
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	</bean>
	
	(2) datasource.xml 파일에 tx 네임스페이스 등록
	
	(3) Spring에 내장된 트랜잭션 어드바이스를 사용 [datasource.xml]
		-> 모든 메소드 네임을 감시하겠다는 의미 [포인트컷]
		-> Aspect 등록
		
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="*" />
		</tx:attributes>
	</tx:advice>
	
	(4) advice를 지정하였으니, 포인트컷을 등록해야 한다. [어스펙트 = 어드바이스 + 포인트컷]
	<aop:config>
		<aop:pointcut expression="execution(* kr.co.acomp.service.*Service.*(..))" id="transactionPointcut" />
		<aop:advisor advice-ref="txAdvice" pointcut-ref="transactionPointcut" />
	</aop:config>
	=======================================================================	
	
	2) 의존성 추가 : 
		- spring-mvc, spring-context에서 commons-logging 배제
		- slf4j, jcl-over-slf4j (java commons logging 대신에 slf4j 쓰겠다.), logback 추가
	=======================================================================	
	(1) spring-context, spring-webmvc에서 commons-logging 제외
  	<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
	<dependency>
    	<groupId>org.springframework</groupId>
    	<artifactId>spring-context</artifactId>
    	<version>4.3.26.RELEASE</version>
    	<exclusions>
    		<exclusion>
      			<groupId>commons-logging</groupId>
    			<artifactId>commons-logging</artifactId>  		
    		</exclusion>
    	</exclusions>
	</dependency>    
    
 	<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
	<dependency>
    	<groupId>org.springframework</groupId>
    	<artifactId>spring-webmvc</artifactId>
    	<version>4.3.26.RELEASE</version>
    	<exclusions>
    		<exclusion>
      			<groupId>commons-logging</groupId>
    			<artifactId>commons-logging</artifactId>  		
    		</exclusion>
    	</exclusions>
	</dependency>
	
	(2) slf4j, jcl-over-slf4j, logback 추가
	<!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api -->
	<dependency>
    	<groupId>org.slf4j</groupId>
    	<artifactId>slf4j-api</artifactId>
    	<version>1.7.30</version>
	</dependency>

	<!-- https://mvnrepository.com/artifact/org.slf4j/jcl-over-slf4j -->
	<dependency>
    	<groupId>org.slf4j</groupId>
    	<artifactId>jcl-over-slf4j</artifactId>
    	<version>1.7.30</version>
	</dependency>

	<!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic -->
	<dependency>
    	<groupId>ch.qos.logback</groupId>
    	<artifactId>logback-classic</artifactId>
    	<version>1.2.3</version>
    	<scope>test</scope>
	</dependency>
	=======================================================================	
	
	3) logback 설정파일을 클래스 패스 추가
	=======================================================================	
	<?xml version="1.0" encoding="UTF-8"?>
	
	<!-- 30초마다 설정 파일의 변경을 확인한다. 파일이 변경되면 다시 로딩한다.  -->
	<configuration scan="true" scanPeriod="30 seconds">
	
		<!-- 외부 설정파일을 사용할 수 있다. -->
		<!-- <property resource="resource.properties" /> -->
	
		<appender name="console" class="ch.qos.Logback.core.ConsoleAppender">
			<encoder>
				<pattern> %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n </pattern>
			</encoder>
		</appender>
		
		<appender name="FILE" class="ch.qos.Logback.core.rolling.RollingFileAppender">
			<file>${APP_HOME}/hello-webbapp.log</file>
			<rollingPolicy class="ch.qos.Logback.core.rolling.TimeBasedRollingPolicy">
				<!-- 파일이 하루에 한개씩 생성된다. -->
				<fileNamePattern>hello-webapp.%d{yyyy-NN-dd}.log</fileNamePattern>
				<!-- 30일이 지난 파일은 삭제 -->
				<maxHistory>30</maxHistory>
			</rollingPolicy>
			
			<encoder>
				<pattern> %-4relative [%thread] %-5level %logger{35} - %msg%n </pattern>
			</encoder>
		</appender>
		
		<logger name="org.springframework" level="info" />
		<logger name="kr.co.acomp" level="debug" />
		
		<root level="debug">
			<appender-ref ref="console" />
			<appender-ref ref="FILE" />
		</root>
	</configuration>	
	
	4) 위와 같이 설정하면 console창에 logback 로그가 뜨지 않는다.
		- SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”
		- 아래에 있던 scope 영역을 다 지워주면 로그가 정상적으로 뜬다!
		
	<!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api -->
	<dependency>
    	<groupId>org.slf4j</groupId>
    	<artifactId>slf4j-api</artifactId>
    	<version>1.7.30</version>
	</dependency>

	<!-- https://mvnrepository.com/artifact/org.slf4j/jcl-over-slf4j -->
	<dependency>
    	<groupId>org.slf4j</groupId>
    	<artifactId>jcl-over-slf4j</artifactId>
    	<version>1.7.30</version>
	</dependency>

	<!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic -->
	<dependency>
    	<groupId>ch.qos.logback</groupId>
    	<artifactId>logback-classic</artifactId>
    	<version>1.2.3</version>
    	<scope>test</scope>
	</dependency>

	=======================================================================	

* 정리 : 
	- 스프링은 선언적 트랜잭션과 프로그래머틱한 트랜잭션 모두지원하고 같이 사용할 수도 있다.
	- 로깅 시스템은 여러가지로 사용 가능하지만 SLF4J를 로깅 인터페이스로 해서
	  Logback이나 Log4J를 구현체로 많이 사용한다.


<2020-04-26 21강 예외처리>
* Spring 예외처리 개요
	- 서버에서 발생된 예외를 최종 사용자에게 전달되는 것을 방지
		- DAO와 Service에서 발생된 예외는 Controller로 모여짐
		- System 예외는 Business 예외로 다시 던지는 (re-throwing) 방식 사용
		- @ExceptionHandler와 @ControllerAdvice를 사용하여 예외를 처리

	- 모든 예외를 모아서 Controller 단에서 처리하는 것을 권장
	- checked exception : try ~ catch
	- unchecked exception : RuntimeException을 상속받은 Exception
	
* Spring 예외처리 특징
	- 컨트롤러 기반
		- 부가기능을 제공하는 Advice 클래스를 작성
		- XML 설정 파일에 <aop:config>를 이용해서 에스펙트를 설정함
	- 글로벌 Exception 핸들러
		- 예외처리는 cross-cutting concern, 어플리케이션 전체에 포인트컷이 적용되어야 함
		- @ControllerAdvice 어노테이션을 포함한 클래스는 전역 예외처리 컨트롤러가 된다.
		- 컨트롤러에서 캐치한 예외는 JSP같은 View나 혹은 Json으로 응답이 가능

* MyBatis에서의 예외처리
	- JDBC 관련 코드는 대부분 SQLException 발생
	- 대부분의 SQLException은 복구가 불가능
	- Spring-MyBatis는 SQLException을 DataAccessException(RuntimeException)으로 re-throwing
	- DataAccessException으로부터 SQLException을 추출하여 getErrorcode() 메서드로 에러코드 확인 가능

* @ControllerAdvice : 
	- Spring 3.2 이상에서 사용 가능
	- @Controller나 @RestController에서 발생하는 예외를 catch
	  [Restful API 용도의 컨트롤러는 별도로 처리 가능하다. 스프링 4.0 이상부터 가능]
	
* @ControllerAdvice 사용을 위한 설정
	- servlet-context.xml에서 ControllerAdvice를 include
	
* 실습 : 
	1) 사용자 예외작성 : BizException
		- 예외 re-throwing at Service
	=======================================================================	
	package kr.co.acomp.exception;
	
	public class BizException extends RuntimeException {
	
		public BizException() {
			super();
		}
		
		public BizException(Throwable t) {
			super(t);
		}
		
		public BizException(String msg) {
			super(msg);
		}
	}
	=======================================================================	

	
	2) 컨트롤러에서 예외 최종적으로 처리
		- @ControllerAdvice (servlet-context.xml 수정)
		- 핸들러가 없는 Exception의 경우 화면에 그대로 표시됨
	=======================================================================	
	(1) GlobalExceptionHandler 작성
	package kr.co.acomp.controller;
	
	import org.springframework.ui.Model;
	import org.springframework.web.bind.annotation.ControllerAdvice;
	import org.springframework.web.bind.annotation.ExceptionHandler;
	
	import kr.co.acomp.exception.BizException;
	
	@ControllerAdvice
	public class GlobalExceptionHandler {
	
		//BizException을 처리할 수 있는 핸들러 작성
		@ExceptionHandler(BizException.class)
		public String handleBizException(Exception e, Model model) {
			
			model.addAttribute("type", e.getClass().getSimpleName());
			model.addAttribute("msg", e.getMessage());
			
			//에러페이지 호출
			return "error";
		}
	}
	
	(2) 테스트용 컨트롤러 / 서비스 
	// 파일 업로드 실습
	@GetMapping("")
	public String index() {
		service.testService();
		return "index";
	}
	
	public void testService() {
		System.out.println("target invoked");
		throw new BizException("testService fail...");
	}
	
	(3) 기존의 logback dependency 수정 [scope 삭제]
	<!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic -->
	<dependency>
    	<groupId>ch.qos.logback</groupId>
    	<artifactId>logback-classic</artifactId>
    	<version>1.2.3</version>
    	<scope>test</scope>
	</dependency>
	
	<!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic -->
	<dependency>
    	<groupId>ch.qos.logback</groupId>
    	<artifactId>logback-classic</artifactId>
    	<version>1.2.3</version>
	</dependency>

	=======================================================================	
	
	3) 에러페이지 작성
		- error.jsp
	=======================================================================	
	<%@ page language="java" contentType="text/html; charset=UTF-8"
		pageEncoding="UTF-8"%>
	<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
	<html>
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Insert title here</title>
	</head>
	<body>
		<h1>에러 발생</h1>
		<h2>error type : ${type}</h2>
		<h2>msg : ${msg}</h2>
	</body>
	</html>	
	=======================================================================	

	* 추가적인 예시를 통해 흐름을 확인해 보자
	=======================================================================	
	(1) ArticleDAO에서 의도적으로 예외를 발생시켜 보자 [오타]	
	public void insertArticle(Article article) {
		sqlSession.insert("mappers.article-mapper.insertArticl", article);
	}
	
	(2) BbsService 
	public void registArticle(Article article) {	
		articleDAO.insertArticle(article);
	}
	
	(3) BbsController
	@GetMapping("")
	public String index() {
		service.registArticle(new Article(5, "kim", "test", "test"));
		return "index";
	}
	
	(4) GlobalExceptionHandler
	//MybatisSystemException을 처리할 수 있는 핸들러 작성
	@ExceptionHandler(MyBatisSystemException.class)
	public String handleMyBatisSystemException(Exception e, Model model) {
		
		model.addAttribute("type", e.getClass().getSimpleName());
		model.addAttribute("msg", e.getMessage());
		
		//에러페이지 호출
		return "error";
	}	
	=======================================================================		


<2020-04-26 22강 인터셉터와 로그인 처리>
* Spring Interceptors : 
	- 모든 요청에서 반드시 거쳐야 하는 서블릿 필터와 유사
	- Servlet Filter와는 다름 [서블릿 필터는 DispatcherServlet 앞에 위치하여 스프링 빈을 사용할 수 없다.]
	- 인터셉터는 컨트롤러 요청에만 적용된다.
	- Bean Container 로딩 후에 적용되기 때문에 빈을 사용할 수 있다.

* 사례 : 로그인 처리
	- LoginInterceptor : preHandle / postHandle / afterCompletion [미리 정의된 call-back 메소드 3개]
	- 요청 -> DispatcherServlet -> LoginInterceptor[preHandle] -> MainController 
		-> LoginInterceptor[postHandle] -> 응답 -> LoginInterceptor[afterCompletion]

* 인터셉터는 총 3부분에 대해서 공통 기능을 넣을 수 있다.
	- preHandle : 컨트롤러 실행 전
	- postHandle : 컨트롤러 실행 후, 아직 뷰를 실행하기 전
	- afterCompletion : 뷰를 실행한 이후
	
* Interceptor는 여러개를 둘 수도 있다.
	- 요청 -> DispatcherServelt -> Interceptor1 -> Interceptor2 -> Controller
	- 중첩될 때 수행순서를 잘 이해해야 함
		- 요청 -> DispatcherServlet
			-> preHandle1 -> preHandle2
			-> Controller
			-> postHandle2 -> postHandle1
			-> View
			-< afterCompletion2 -> afterCompletion1

* Interceptor 사례 : 웹 요청 처리시간 측정기
	- preHandle과 afterCompletion을 이용한 웹 요청 처리 시간 측정기
	- 웹 사이트에서 어떤 URL이 가장 많이 호출되고, 얼마나 많은 시간이 걸리는지 알 수 있는 방법이다.

* 인터셉터 생성
	=======================================================================	
	(1) 인터셉터 코드 작성

	(2) servlet-context.xml 설정
	<mvc:interceptors>
		<bean id="measuringInterceptor" class="kr.co.acomp.interceptor.MeasuringInterceptor" />
	</mvc:interceptors>
	
	(3) 특정 URL만 지정하여 설정
		- /test/로 시작하는 모든 URL, /event/로 시작하는 모든 URL에  
		  MeasuringInterceptor를 적용하고 그 외에는 적용하지 않는다.
		- Interceptor가 선언된 순서대로 실행된다.
	<mvc:interceptors>
		<mvc:interceptor>
			<mvc:mapping path="/test/**/" />
			<mvc:mapping path="/event/**/" />
			<bean id="measuringInterceptor" class="kr.co.acomp.interceptor.MeasuringInterceptor" />
		</mvc:interceptor>
	</mvc:interceptors>	
	=======================================================================	

* 로그인 체크하는 로그인 Interceptor 만들기
	- preHandle을 이용한 로그인 체크기 제작
	- 컨트롤러마다 로그인을 체크하는 중복 코드를 만들지 않고 로그인 체크하기

	=======================================================================	
	(1) 인터셉터 코드 작성
	

	=======================================================================	

* 실습 : 
	1) 인터셉터 작성
	=======================================================================	
	package kr.co.acomp.interceptor;
	
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	
	import org.slf4j.Logger;
	import org.slf4j.LoggerFactory;
	import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
	
	public class MeasuringInterceptor extends HandlerInterceptorAdapter {
	
		Logger log = LoggerFactory.getLogger(MeasuringInterceptor.class);
		
		@Override
		public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
				throws Exception {
			
			request.setAttribute("mi.beginTime", System.currentTimeMillis());
			return true;
		}
	
		@Override
		public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
				throws Exception {
	
			long beginTime = (long)request.getAttribute("mi.beginTime");
			long endTime = System.currentTimeMillis();
			log.debug(request.getRequestURI() + "실행시간 : " + (endTime - beginTime));
		}		
	}
	=======================================================================		

	2) 인터셉터 설정 [servlet-context.xml]
	=======================================================================	
	- 인터셉터는 컨트롤러에 반응한다.
	- /bbs/ 요청에  대해 인터셉터가 적용되도록 설정
	<mvc:interceptors>
		<mvc:interceptor>
			<mvc:mapping path="/bbs/**/" />
			<bean id="measuringInterceptor" class="kr.co.acomp.interceptor.MeasuringInterceptor"></bean>
		</mvc:interceptor>
	</mvc:interceptors>	
	=======================================================================	





<후기>
* Spring 빈 설정 xml파일이 3개로 나뉘어진 후 Junit 테스트가 안된다.
  xml파일을 1개 읽으면 문제가 없지만, DB까지 연계된 테스트를 진행할 경우
  최소한 2개의 컨텍스트를 사용해야 하는데, *.xml을 사용해도 계속 에러가 발생하고 있다.




